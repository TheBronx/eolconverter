EolConverter va a ser una interfaz, implementada por:
 - Utf8Converter
 - Utf16Converter
 - Utf32Converter
 - NullPatternConverter -> simplemente devuelve los mismos bytes que recibe, no convierte nada

 Un EolConverter concreto recibe un Chunk y devuelve un Chunk con los Eol debidamente cambiados.
 Chunk es un conjunto de bytes, es decir consta de:
  - un array de bytes
  - un int dataLength que indica cuantos de esos bytes son datos
  - ¿? y si meto el tipo de EOL aqui? para tests puede estar bien?

 EolDataConverter.convert() consistirá en:
 - Adivinar el encoding (EncodingGuesser) -> Encoding.UTF8, Encoding.UTF16, Encoding.UTF32 o Encoding.UNKNOWN
 - Dependiendo del encoding obtener el correspondiente EolConverter
 - Pedirle al EolConverter de turno que convierta los bytes que nos han pasado
 - Devolver los bytes resultantes y el tamaño de los datos

 Me falta una clase que sepa trocear los bytes dependiendo del encoding. Los EolConverter van a recibir muchos bytes, tienen que parsear ese churro por caracteres.
 Alguien que sepa que en UTF-32 los caracteres son de 4 bytes, mientras que en UTF-16 los caracteres son de 2 o de 4 bytes, y que en UTF-8 pueden ser de 1, 2, 3 y hasta 4 bytes.
 Alguien que dado un array de bytes y una posición me diga cuántos bytes leer a partir de ahí, si 1, 2, 3 o 4.
 Algo como un Parser. Con implementaciones dependiendo del encoding.
 int bytesToRead = Parser.nextCharSize(byte[] data, int position)

 while(bytesToRead != -1 && position<= dataLength) {
    bytesToRead = Parser.nextCharSize(byte[] data, int position)
    Chunk toConvert = new Chunk( {data desde position hasta position+bytesToRead} )
    Chunk converted = EolConverter.convert(toConvert);
    //guardar el converted en el array de bytes de destino y aumentar el contador de bytes destinationDataLength
    //la clase Chunk me sobra creo, van a ser muchisimos objetos, uno por cada char del texto, y voy a tener que irlos juntando, un coñazo
    //quizas el EolConverter.convert() debe recibir bytes[] y devolver simplemente bytes[], me sobra el dataLength aqui ya que los array de bytes los voy a crear del tamaño adecuado siempre
 }